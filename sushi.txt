
＃　SuSHi Tool Version 0.01

＃　SuSHi Toolとは

ネット上のOSS監視ツールの選定に悩む日々。
様々なツールのメリット、デメリットをマトリックスにしてもぽっかりと空く部分の要件を満たせるものは見つからず、
結局は運用回避する部分が発生し、他ツールに頼る、他のメリット、デメリットが発生、また他のツールを探すの繰り返し。

そんなとある日曜の昼、回転寿司に入店。

「ポテトとラーメンって寿司屋だぞ！ここは！！」
「そっちは穴子しか頼んでないじゃん！しかも100円皿じゃないし！！」

そんな会話の後、図らずも相当な精神状態だったのか、監視ツールの事を思い出す。

・・・あれ？

　お客さん　　→　監視対象サーバー
　回転レール　→　アラート処理を行うサーバー
　注文パッド　→　監視設定サーバー
　
ってなれば良いんじゃないの？とピコーンと発想
そんなコンセプトで作られた監視ツールというか、SSHを介したジョブ伝播ツールがこのツールとなります。

　お客さん　　→　エージェント　→　サーバーからの実行命令(実はスクリプトファイル)をダウンロードし、実行のみ行います。
　　　　　　　　　　　　　　　　　　実行後は結果を寿司の空皿のようにサーバー部分に返送します。（実際は回転寿司は空皿をレールに載せません！！）
　　　　　　　　　　　　　　　　　　動作はデーモンでなく、cronで単発のコマンドを短期に実行する方式となっています。
　　　　　　　　　　　　　　　　　　これによりタイムアウトも無く、処理の衝突を避けた確実な1ジョブの実施が可能となっています。
　　　　　　　　　　　　　　　　　　サーバー部分へのアクセスはSSHの仕組みを使用します。
　　　　　　　　　　　　　　　　　　サーバー部分へSSHのアクセスが出来れば良いのでroot権限は必須となりません。
　　　　　　　　　　　　　　　　　　アプリケーションの動作権限でも監視対象に組み込むことが可能です。
　　　　　　　　　　　　　　　　　　サーバー部分に問い合わせし、サーバー部分の自アカウントにあるoutフォルダにある実効命令（実際はスクリプト）を
　　　　　　　　　　　　　　　　　　ダウンロードして、ローカルで実施してから再アップロードを繰り返します。
　　　　　　　　　　　　　　　　　　agentはoutboundのSSH通信のみで動作しますので監視対象サーバーはinboundのファイアウォールの開放不要です。

　回転レール　→　サーバー部分　→　サーバーからの皿（実行結果）を参照し、内容とエラー回数を確認します。
　　　　　　　　　　　　　　　　　　エラー判定の場合は対処方法をエージェントに渡すように処理します。
　　　　　　　　　　　　　　　　　　特定の皿・・・というかエラーカウントが閾値越えすると最終アクションをエージェントに送ります。
　　　　　　　　　　　　　　　　　　こちらもcronで短期の実行を繰り返す方式です。デッドロック、処理の衝突に対応しています。
　　　　　　　　　　　　　　　　　　動作として各/home配下を参照する動作を繰り返します。alert.confが無ければこのツール用のアカウントとして扱いません。
　　　　　　　　　　　　　　　　　　alert.confがあれば続いてinフォルダのAgentからのアップロード内容を確認し、alert/action/resultフォルダの内容と
　　　　　　　　　　　　　　　　　　比較してoutフォルダに結果を置きます。metricフォルダは実行結果を貯め、メトリック検索に使用します。
　　　　　　　　　　　　　　　　　　alertcountはアラートがクリティカルに達する閾値をカウントします。pswdはアカウントのパスワードを示します。

　　　　　　　　　　　　　　　　　　各監視対象サーバーの管理は全てSSHとOSのアカウント管理にて実装しています。
　　　　　　　　　　　　　　　　　　特にサーバー毎のアカウント重み付けは行っておらず、/home配下のユーザーアカウントとしか見えません。
　　　　　　　　　　　　　　　　　　全ての監視用アカウントについて/home配下のユーザーディレクトリに設定ファイルなど監視設定情報が配置されています。

　注文パッド　→　ＡＰＩ部分　　→　REST APIで設定要求を受け付け、反映させます。
　　　　　　　　　　　　　　　　　　指定ポートで待ち受けてエンドからの要求を待ち受けます。ファイルの入出力はサーバー部分に従います。

上記のように他ツールとの連携を捨て、とことんレガシーの処理の組み合わせで要件の実現とボトルネック部分を
省くことに焦点を当て、デッドロックと大規模運用に耐えられるよう実装しました。あ、グルーピング機能の実装にredisは使ってますが。。

まとめ：　このツールは以下の特徴があります。

　１．　outboundの通信のみで監視可能
　　-　内側の通信許可不要なので強固なセキュリティ要件でも対応できる！
　２．　go言語で作られているのでインストールはバイナリの配置のみ
　　-　ワークフレームや他のツールをインストールする前提が無く、迅速な環境デプロイ！
　３．　リポジトリ、グループ、クラスターモードを実装
　　-　設定のリポジトリによる監視方法の切り替え迅速化、複数設定も一度に実行、冗長性も確保！
　４．　フルAPI
　　-　全ての項目をAPIのみで監視設定可能！
　５．　柔軟な監視設定が可能
　　-　実行命令を仕掛ける方法なのでツール内の動作のクセを意識せず監視設定できる！

ＳＴＥＰ１：　各ツールの起動方法とオプションを知ろう！

このツールはgo言語にて実装されていますので単一のバイナリファイルとなります。
レガシー化に特化したため設定ファイルは持たず、あえてオプション指定でしか設定できないような仕組みになっています。いいようなわるいような。
よって通常のツールではコンフィグファイルで設定する部分を全て起動オプションにて指定すると思ってください。

エージェント部分：　ファイル名／agent

[-ip=IP Address] コントローラのIP
　サーバー部分が動作しているIPアドレスを指定します。　例) -ip=192.168.0.1
[-port=Port Number] 接続ポート
　サーバー部分が動作しているサーバーのSSHDの待ち受けIPを指定します。デフォルトは22です。　例) -port=1022
[-user=User Account] サーバーのユーザーアカウント
　サーバー部分で使用するアカウント名を指定します。指定するアカウント名はAPIによる初期化（監視登録）時に使用したものです。
[-key=(KEY FILE)] 鍵ファイルのパス
　初期化（監視登録）時にダウンロードした鍵ファイルを指定します。
[-l] no lock mode **WARNING!**
　デフォルトではサーバー部分へのアクセス時に指定したアカウントにおいて処理が行われている場合に、ロック状態として処理を停止しますが
　cron登録の仕組み上、時間と処理が衝突して動作し辛い（次のcron待ちになる）場合もありえます。
　その場合、設定の整合性を無視し、検出スピードを速めるため当オプションにてロック処理を無視させます。大規模運用時有効です。
[-pwd=Directory] 実行ディレクトリ[default:/opt/sushi]
　実行ディレクトリがユーザーにて変更がある場合指定します。デフォルトは /opt/sushiになります。

例）初期化（監視登録）後にcronへの登録前に以下のように動作を試すことを推奨します。設定が正しければ正常にアラートの確認へ進みます。
　/opt/sushi/agent -ip=192.168.0.15 -port=22 -user=kato2 -key=/opt/sushi/key

インストール方法：
特定のディレクトリにフォルダを掘り、ダウンロード後に実行権を与え、cronに登録してください。
なお、サーバー部分のセットアップが無いと動かないので環境構築はサーバー部分を先に実施してください。

① mkdir -p /opt/sushi/out ; cd /opt/sushi
 - Agent配置用のディレクトリを作成します。
② curl -k "https://192.168.0.15:1880?cmd=agentget&account=kato3_test" -o agent ; chmod 700 agent
 - Agentをサーバー部分よりダウンロードします。見ての通り既存アカウントでの認証が必要となります。
③ echo "* * * * * for i in `seq 0 15 59`;do (sleep ${i} ; timeout 60 /opt/sushi/agent -ip=192.168.0.15 -port=22 -user=kato3 -key=/opt/sushi/key >> /var/log/agent.log) & done;" >> /var/spool/cron/crontabs/root
 - ダウンロードしたAgentをcronに組み込みます。今回rootでAgentを実行するためrootのspoolに追記しますが
 一般ユーザーでAgentを動かす場合はユーザーのspoolファイルに追記する必要があります。
 この例の場合 15秒間隔でAgentが動作する設定になります。

コントローラ部分：　ファイル名／ctl

[-aes=(文字列)] 暗号化文字列(Default:password)
　initのAPIについて何でも許可し、アカウントを作成されないように認証パスワードを設けます。APIのinit実施時はこの値を指定する必要があります。
[-mode=1,2,3] 1:Single(Default) 2:Remote(Require Auth) 3:Cluster(Require Auth)
　動作モードを指定します。1はxコントローラとサーバー部分の同居モードの小規模運用時を示します。
　-mode=2はリモートモードを示します。サーバー部分と分離したい場合に使用します。オプションにはSSHの認証情報を指定します。
　　例）/opt/sushi/ctl -mode=2 -auth=root,/root/.ssh/id_rsa,centos00,22
　　※root権限のあるアカウント、サーバー鍵、サーバー名、ポート番号で指定します。
　　　起動時に指定したサーバーへのアクセスが妥当かチェックが入ります。
　-mode=3は2台以上のクラスタモードを示します。以下例のように-mode=2/リモートモードの指定を ~ で区切ることで
　　複数コントローラを同一監視セグメントとして運用できます。APIによってクラスタモードの動作は変わるので以後ドキュメントにてご確認ください。
　　 ~ で区切る事で3台以上も指定可能ですが多重化し過ぎると、台数分への問い合わせが発生するためAPIの応答スピードが比例して低下していきます。
　　各サーバーのパラメータはカンマ区切りで以下のように指定します。
　　
　　-auth,(root権限のアカウント名),(秘密鍵ファイル),(サーバー名、またはIP),(接続ポート)~・・・※3台以上 ~ 区切りで指定可能です。
　　
　　例) go -mode=3 -auth=root,/root/.ssh/id_rsa,centos00,22~root,/rot/.ssh/id_rsa,10.0.0.19,22
　　
　　通常の秘密鍵でのSSH接続が行えればセットアップ完了です。該当サーバーのroot権限アカウントの.ssh/authorized_keysに
　　同フォルダのid_rsa.pubを追記して同フォルダの秘密鍵ファイルを抜き出してくれば完了です。
　　なお、クラスターモードにおいてもグループ指定できるAPIは全てグループ指定可能です。
　　
　　※※※注意※※※
　　　クラスターモードには以下、構成時に付帯して準備する必要があるものがあります。
　　　ツール内では実装していないのでクラスターモード使用時の構成にあわせてご準備ください。
　　　
　　　　１． rsyncd+lsyncdなど/homeのリアルタイム同期、または/homeのNFS移行など/home配下の情報同期
　　　　　API自体にはクラスター内で取得できる情報で矛盾しないよう全サーバーへの書き込みや、またダウンしているサーバーを飛ばして処理を継続する仕組みが
　　　　　設けられていますが、ダウンから復旧した際に同期されないため、二度目のダウンで不整合が発生します。
　　　　　それを防ぐには復旧時に同期する仕組みや、常に同じ領域を参照させる必要があります。

　　　　２． アカウント情報の同期
　　　　　前項に続きますがダウン-復旧時までに新しくアカウントが作られていた場合、前項でデータをコピーしていても
　　　　　OS上のアカウントが無いので、既にあるアカウントが上書きで作れてしまうなど矛盾した動作が発生する可能性があります。
　　　　　そのため、復旧時にアカウントを同期する仕組みが必要となります。またはLDAPなどで外部にアカウント情報を持つでも構いません。

　　　　３． DNS、LBなどによる問い合わせ先の冗長化
　　　　　Agentの接続するサーバーは一台あれば全台にアップロードしなくても情報に不整合が起きない仕組みが設けられています。
　　　　　sv、ctlの仕組みと/homeの同期などの共通化で対応可能です。ただし、VIPなどでAgentの通信を振り分けてアップロードさせる仕組みが必要です。
　　　　　DNSでラウンドロビンさせるか、svの前段ネットワークにLBをご準備ください。
　　　　　
　　　　４． redisの同期
　　　　　グループ指定の実装にredisを使っています。そのため、ダウン時はグループの参照以外の追加や、削除のAPI操作は同期できません。
　　　　　redisの同期など何らかの方法で情報の一貫性を保つ必要があります。ソースを書き換えて外部PaaSのredisを使うのもアリです。
　　　　　
　　　　５． ログ
　　　　　明示的なログ出力はしません。標準出力をファイルにリダイレクトするなどで対応してください。
　　　　　またログローテートの機能は無いのでログを採取する場合は空き容量にご注意ください。
　　※※※注意※※※
　　
[-port=(Port Number)] ポート番号(Default:1880)
　待ち受けるポート番号を指定します。
[-crt=(CRT File)] CRTファイルのパス(Default:./myself.crt)
　APIはSSH接続必須となるため証明書の指定が必要です。CRTファイルを指定します。
　なお、オレオレ証明書を使用した場合API実行時に不正な証明書を無視するオプション指定が必要となります。
[-key=(KEY File)] KEYファイルのパス(Default:./myself.key)
　同上ですがKEYファイルを指定します。
[-d] debug mode
　デバッグモードになります。細かいコマンド実行など内部的なログが全て出力されます。

インストール方法：
特定のディレクトリにフォルダを掘り、実行権を与えて実行するだけです。
APIリクエストがあった場合にAgentをダウンロードさせる機能があるのでctlと同フォルダに
Agentのバイナリファイルを配置してください。つまりAgentがバージョンアップした場合はファイルの差し替えのみで動的に対応可能です。

① ./ctl -d

httpsで指定したポートで待ちうけが発生します。
OS起動時に実行させておきたい場合はCentOSであればchkconfig/systemdへの登録などOS側機能を利用してください。
なお、AgentとSvの動作には一切関わりませんので不要なときは停止させておく運用も可能です。

サーバー部分：　ファイル名／sv

[-timeout=(タイムアウト秒)] Agentからの通信途絶時間
　サーバー部分ではAgentからの通信途絶時間を確認し、サーバー側でDisconnect状態と判断する機能があります。
　そのタイムアウト時間をオプション指定します。

インストール方法：
特定のディレクトリにフォルダを掘り、ダウンロード後に実行権を与え、cronに登録してください。
グループ機能の実装にredisを使用しています。svを実行するサーバーではあらかじめredisを起動させてください。
redisの待ち受けポートはわかりやすく・・いや手抜きで標準のポート6379です。ctlから127.0.0.1のローカルアクセスします。

① mkdir -p /opt/sushi/out ; cd /opt/sushi
 - Agent配置用のディレクトリを作成します。
② svのバイナリファイルをscpなどでコピーしてきてから配置し、実行権限を chmod 700 svなどで与えます。
③ echo "* * * * * for i in `seq 0 15 59`;do (sleep ${i} ; timeout 60 /opt/sushi/sv -timeout=60 >> /var/log/sv.log || find /home -name "_lock_" -exec rm -f {} \; ) & done;" >> /var/spool/cron/crontabs/root
 - svをcronに組み込みます。rootでsvは実行する必要があるのでrootのspoolに追記してください。
 この例の場合 15秒間隔でsvが動作する設定になります。svの更新間隔が長く、Agentが短い場合、
 どんどんAgentからのアップロードが溜まりますので必ず sv < Agentの実行間隔としてください。
 目安としては svはAgentの1.5倍以上の間隔が適していると判断しています。
 またtimeoutコマンドにてタイムアウトを検出した場合はロックファイル(_lock_)を全アカウントで開放するようfind～の行を必ず入れてください。
 Agentから見てロックされたままになる可能性があります。

ＳＴＥＰ２：　ＡＰＩを知ろう！

ctlは大きく2種類のAPIを持ちます。GETとPOSTのAPIです。
POSTは実行スクリプトのアップロードのみに使用します。その他のAPIは全てGETを使用します。

APIからの応答について

APIからの応答は一部例外を除いて全て以下の形式で応答が返ってきます。
{"title":"xxx","message":"xxx","status":"xxx"}
titleにはAPI名、messagesには応答内容、statusには成功がok、失敗がfailで入ります。
なんちゃってJSONなのでmessagesは改行コードがそのまま以下のように出力されます。

{"title":"xxx","message":"aaa\nbbb\n","status":"ok"}

なぜこのような出力になっているかというとinitのAPIを実現することと、この出力が一定であれば
JSONを読み込んでから二次加工する手間が省けるからと・・・いや、手を抜いたからです・・

【GET系】

☆基本ルール
・APIの指定はGETの形式で指定します。GETですのでctlが動作しているURLの後に?～&～のように続けます。
・ _ (アンスコ)は特殊文字です。文字列の区切りに指定します。よって定義名などには使用できないのでご注意ください。
・APIの実行先となるアカウント、またはグループの指定が必須です。
・アカウント、またはグループの指定は _ で区切り、名前_パスワード という形式で指定します。グループの指定は以下のようになります。
　curl -k "https://192.168.0.15:1880?group=webgroup_passwd&cmd=status"
　account=がアカウント指定、group=がグループ指定になります。
・APIの種別はcmd=で渡します。
・APIに設定するパラメータはparams=などAPIの種別に沿って指定します。

 "status":　ステータスを確認する
サーバーの動作ステータスを表示します。svで定義したタイムアウト内でアップロードのあるサーバーはAlive、
来なかったものはDisconnectで表示されます。後に状態が確認された日付が続きます。
次の行から監視項目の状態が表示されます。問題ないものはNORMAL、異常があり復旧アクションが行われているものはWARNING、
復旧できずに最終アクションが行われたものはERRORが表示されます。

　指定ルール
　アカウント、またはグループと&cmd=statusを指定してください。
　　グループの場合：
　　　アカウント毎に -- (アカウント名) --で区切られた形式で表示されます。
　　クラスターの場合：
　　　クラスター内で最新の情報のみ表示します。

例)
curl -k "https://192.168.0.15:1880?account=kato_test&cmd=status"
curl -k "https://192.168.0.15:1880?group=webgroup_passwd&cmd=status"

 "ruleshow":　設定されているルールを指定する
アカウントに設定されているルールを表示します。ルールは一行ずつ改行されて表示されます。

　指定ルール
　アカウント、またはグループと&cmd=ruleshowを指定してください。
　　グループの場合：
　　　アカウント毎に -- (アカウント名) --で区切られた形式で表示されます。
　　クラスターの場合：
　　　クラスター内で最新の情報のみ表示します。

例)
curl -k "https://192.168.0.15:1880?account=kato_test&cmd=ruleshow"

 "groupget":　グループ設定状態を表示する
グループ指定されているアカウント情報を表示します。アカウントは名前とパスワード１セットで紐づけられたものが全て表示されます。

　指定ルール
　params=でグループと&cmd=groupgetを指定してください。
　　グループの場合：
　　　グループ情報の取得なのでグループ指定が出来ません。
　　クラスターの場合：
　　　クラスター内で最新の情報のみ表示します。

例)
curl -k "https://192.168.0.15:1880?account=kato_test&cmd=groupget&params=group1_test"

 "groupset":　グループ指定を設定する
新たにグループを作成します。accounts=パラメータにて複数アカウントを指定してグループ化します。

　指定ルール
　params=で新規グループと&cmd=groupgetを指定してください。accounts=でグループ化するアカウントを指定します。
　 , (カンマ)区切りで複数アカウントをグループ指定できます。params=は _ 区切りでパスワードも指定してください。
　　グループの場合：
　　　グループ情報の設定なのでグループ指定が出来ません。
　　クラスターの場合：
　　　クラスター内で最新の情報のみ表示します。

例)
curl -k "https://192.168.0.15:1880?account=kato_test&cmd=groupset&params=group1_test&accounts=kato_test,test16_pugqha"

 "grouplist":　自分の作ったグループを表示します。

　指定ルール
　account=で自分のアカウントを指定して、作成したグループを一覧で表示します。
　　グループの場合：
　　　アカウントに紐づくグループ情報の表示なのでグループ指定が出来ません。
　　クラスターの場合：
　　　クラスター内で全てでグループ設定します。

例)
curl -k "https://192.168.0.15:1880?account=kato_test&cmd=grouplist"

 "groupdel":　グループ設定を削除します。
作成したグループを削除します。アカウントに紐づいたグループとして指定が必要です。

　指定ルール
　account=で自分のアカウントを指定し、paramsに削除したいグループを指定します。
　　グループの場合：
　　　アカウントに紐づくグループの削除なのでグループ指定が出来ません。
　　クラスターの場合：
　　　クラスター内で全てでグループを削除します。

例)
curl -k "https://192.168.0.15:1880?account=kato_test&cmd=groupdel&params=group2_test"

 "ruleset":　監視ルールを設定します。
監視ルールを設定します。ルールに基づいてアクション、最終アクションが動作します。

　指定ルール
　アカウント、またはグループでルールを設定します。ルールは _ 区切りで４つならべます。
　１つめ；　ルール名を指定します。ここで指定したルール名はアラート、アクション、最終アクションとの紐づけができるよう同じ名前を指定してください。
　２つめ：　検出ルールです。 s:文字が含まれていると異常 S:含まれていないと異常 d:数値が大きいと異常 D:小さいと異常
　　　　　　という判定式になります。dまたはDの指定は一行の整数が出力としてアップロードされるよう実行結果を考慮しなければなりません。
　３つめ：　前項の指定の判定になります。s/Sなら文字列、d/Dなら数値を指定してください。文字列の場合は正規表現を使用可能です。
　４つめ：　アクションを繰り返す回数です。繰り返して復旧しないなら最終アクションが実行されます。（最終アクションの定義が無ければ何も起きません）
　　グループの場合：
　　　グループ内のアカウント全てに同ルールが設定されます
　　クラスターの場合：
　　　クラスタ内のアカウント全てに同ルールが設定されます

例)
curl -k "https://192.168.0.15:1880?group=group1_test&cmd=ruleset&params=apache_s_active.*running_5"

 "ruledel":　監視ルールを削除します。
監視ルールを削除します。

　指定ルール
　アカウント、またはグループでルールを設定します。params=でルール設定時の定義名を指定します。
　　グループの場合：
　　　グループ内のアカウント全てでルールが削除されます
　　クラスターの場合：
　　　クラスタ内のアカウント全てでルールが削除されます

例)
curl -k "https://192.168.0.15:1880?group=group1_test&cmd=ruledel&params=tesco"

 "agentget":　Agentのダウンロード
Agentのバイナリをダウンロードします。Agentのバイナリファイルはctlと同じフォルダ配下にあるものが対象になります。
例外のAPIとしてJSON形式で応答しないため以下例のようにファイル化してください。

　指定ルール
　アカウント、またはグループなどシステム上認証が通るものを指定します。バイナリそのものが返ってくるので例）のように
　出力をファイルに落とす指定が必要です。
　　グループの場合：
　　　アカウント指定と変わりません。認証許可を持ってバイナリが返信されます。
　　クラスターの場合：
　　　クラスタ内で応答出来た最初のサーバーのAgentが返信されます。

例)
curl -k "https://124.24.60.251:1880?cmd=agentget&account=kato3_test" -o agent

 "commit":　アップロード済みの実行スクリプトをコミットします。
実行スクリプトのアップロード後、レポジトリ内でしたい実行スクリプトをコミットします。つまりコミットしないと実行対象になりません。
このシステムだと一番「あれ？動かないんだけど・・」になりがちな部分です。

　指定ルール
　アカウント、またはグループなどアップロード時などに出力されるリポジトリを指定します。
　　グループの場合：
　　　全てのグループでコミットされます。
　　クラスターの場合：
　　　全てのサーバーでコミットされます。

例)
curl -k "https://192.168.0.15:1880?cmd=commit&to=alert&account=kato_test&params=apache_2017-02-12-01-11-35"

 "uncommit":　コミットの解除
コミットを解除します。注意として解除しても元のリポジトリファイルは消えず残り続けます。（あたりまえですが）

　指定ルール
　アカウント、またはグループでrulesetで指定したルール名を指定します。コミット時に指定したリポジトリ名でないので注意
　　グループの場合：
　　　全てのグループでコミット解除されます。
　　クラスターの場合：
　　　全てのサーバーでコミット解除されます。

例)
# curl -k "https://124.24.60.251:80?cmd=uncommit&to=alert&account=kato_test&params=acheck"

 "commitcat":　コミット状況
ルール名にコミットされているファイルとその中身を表示します。

　指定ルール
　アカウント、またはグループでrulesetで指定したルール名を指定します。コミット時に指定したリポジトリ名でないので注意
　　グループの場合：
　　　全てのグループでコミット状況が表示されます。
　　クラスターの場合：
　　　全てのサーバーでコミット状況が表示されます。

例)
# curl -k "https://192.168.0.15:1880?account=kato_test&cmd=commitcat&to=alert&params=apache"

 "repolist":　リポジトリファイルの一覧を表示
アップロード済みのリポジトリファイルを一覧で出力します。

　指定ルール
　アカウント、またはグループでrulesetで指定したルール名を指定します。コミット時に指定したリポジトリ名でないので注意
　　グループの場合：
　　　全てのグループでリポジトリ一覧が表示されます。
　　クラスターの場合：
　　　全てのサーバーでリポジトリ一覧が表示されます。

例)
# curl -k "https://124.24.60.251:80?cmd=repolist&to=action&account=kato_test"

 "repocat":　リポジトリの表示
アップロード済みのリポジトリファイルの中身を出力します。

　指定ルール
　アカウント、またはグループでリポジトリファイル名を指定します。rulesetで指定したルール名で無いので注意
　　グループの場合：
　　　全てのグループでリポジトリファイルの中身が表示されます。
　　クラスターの場合：
　　　全てのサーバーでリポジトリファイルの中身が表示されます。

例)
root@ubuntu00:~# curl -k "https://192.168.0.15:1880?account=kato_test&cmd=repocat&to=alert&params=apache_2017-02-12-01-11-35"

 "repodel":　リポジトリの削除
アップロード済みのリポジトリファイルを削除します。

　指定ルール
　アカウント、またはグループでリポジトリファイル名を指定します。rulesetで指定したルール名で無いので注意
　なお、コミット中のリポジトリファイルを削除すると対象のアラート、アクション、または最終アクションが動作しなくなります。
　再開するには他のファイルをコミットする必要があります。
　　グループの場合：
　　　全てのグループでリポジトリファイルが削除されます。
　　クラスターの場合：
　　　全てのサーバーでリポジトリファイルが削除されます。

例)
root@ubuntu00:~# curl -k "https://192.168.0.15:1880?account=kato_test&cmd=repodel&to=alert&params=apache_2017-02-12-01-11-35"

 "init":　アカウント作成
新規アカウントを作成します。例外のAPIとしてJSONのstatusにアクセス用のSSH鍵を返します。
出力結果を編集しても問題ないですが以下例のようにする事で直接ファイルに落とし込めます。

　指定ルール
　アカウント作成のAPIなのでアカウントや、グループの指定は不要です。
　password=にctl起動時に指定したパスワードを指定してください。デフォルトはpasswordです。
　params=でアカウント名 _ パスワードという形式で指定します。
　　グループの場合：
　　　アカウントを作成するAPIなのでグループ指定はできません。
　　クラスターの場合：
　　　全てのサーバーで同一アカウントが作成されます。

例)
echo `curl -s -S -k "https://192.168.0.15:1880?cmd=init&password=password&params=kato3_test" | cut -d "\"" -f 12` | sed -e 's/\\n/\n/g' -e 's/\\t/\t/g' > key ; chmod 600 key

 "repocopy":　リポジトリをコピー
コミット状況を含めてアカウントのリポジトリを全コピーします。
アラートルール、アラートのカウント状況、アラート、アクション、最終アクションが対象となります。
ステータス、パスワードやメトリック値についてはコピーされません。

　指定ルール
　to=にコピー先アカウントを指定します。指定方法は通常のアカウントの指定方法と同じです。
　　グループの場合：
　　　アカウント単位でコピーするのでグループ指定はできません。
　　クラスターの場合：
　　　全てのサーバーでアカウント間のコピーが行われます。

例)
curl -k "https://192.168.0.15:1880?account=kato_test&cmd=repocopy&to=kato3_test"

 "metric":　メトリック値検索
過去のアラート状況を検索します。監視状況の推移を確認することが可能です。

　指定ルール
　to=にアカウント、またはグループでrulesetで指定したルール名を指定します。コミット時に指定したリポジトリ名でないので注意
　params=に C または T と数値または_区切りで期間を指定します。
　Cの指定は -3なら3日前まで（現在時間?72時間前）、3なら3日前（72時間前?96時間前）、+3なら3日前以降（72時間前?過去）になります。
　Tの指定は-区切りで期間を指定します。
　　グループの場合：
　　　全てのグループの検索結果が表示されます。
　　クラスターの場合：
　　　全てのサーバーから検索結果を取得し、マージしたものを表示します。
　　　これによりAgentから全てのサーバーにアップロードしなくても総合的な検索結果になることを保証します。

例)
# curl -k "https://192.168.0.15:1880?account=kato_test&cmd=metric&to=apache&params=C_-2"
# curl -k "https://192.168.0.15:1880?account=kato_test&cmd=metric&to=apache&params=T_2017-01-18_2017-01-20"

【POST系】

☆基本ルール
・APIの指定はPOSTの形式で指定します。例のように-Fで各パラメータを指定してください。
・例のようにcurlの機能で@を使ってアップロードするファイルを指定してください。
・APIの実行先となるアカウント、またはグループの指定が必須です。
・アカウント、またはグループの指定は _ で区切り、名前_パスワード という形式で指定します。
　account=がアカウント指定、group=がグループ指定になります。
・GETのようにAPIの種別はありません。リポジトリのアップロードのみになります。

　指定ルール
　rulename=にアカウント、またはグループでrulesetで指定したルール名を指定します。コミット時に指定したリポジトリ名でないので注意
　to=にアラート(alert)、アクション(action)、最終アクション(result)を指定してアップロード先のリポジトリを指定してください。
　file=には@でアップロードするファイル名を指定します。
　　グループの場合：
　　　全てのグループのリポジトリにアップロードされます。
　　クラスターの場合：
　　　全てのサーバーのリポジトリにアップロードされます。

例)
curl -k -X POST https://192.168.0.15:1880 -F file=@b -F account=kato_test -F to=action -F rulename=acheck

ＳＴＥＰ３：　実際に設定してみよう！

実際の設定は以下の流れになります。

１．svとctlを動作させるホストを決め、各バイナリを配置します(agentも配置)。svはcron、ctlはsystemdなどサービスへ登録します。
２．監視対象サーバーからinitを実行し、アカウントを作成。agentをダウンロードしてcronに登録します。
４．ctlへアラート、アクション(必須ではない)、最終アクション(必須ではない)をリポジトリにアップロードします。
５．アップロードしたリポジトリファイルをコミットし、最後にルールを定義します。

後は監視、運用状況にあわせて適時リポジトリやルールの更新を行います。
実際のコマンドなど捕捉は以下に記載します。

１．svとctlを動作させるホストを決め、各バイナリを配置します(agentも配置)。svはcron、ctlはsystemdなどサービスへ登録します。

svをcronに登録する場合はroot権限のcrontab -eで以下のように記述します。
svコマンド自体のタイムアウト60秒、監視タイムアウト60秒で15秒間隔で動作させる例です。

* * * * * for i in `seq 0 15 59`;do (sleep ${i} ; timeout 60 /opt/sushi/sv -timeout=60 >> /var/log/sv.log || find /home -name "_lock_" -exec rm -f {} \;) & done;

２．監視対象サーバーからinitを実行し、アカウントを作成。agentをダウンロードしてcronに登録します。

agentも同様以下のようにcronに登録します。

* * * * * for i in `seq 0 15 59`;do (sleep ${i} ; timeout 60 /opt/sushi/agent -ip=192.168.0.15 -port=22 -user=kato2 -key=/opt/sushi/key >> /var/log/agent.log) & done;

４．ctlへアラート、アクション(必須ではない)、最終アクション(必須ではない)をリポジトリにアップロードします。

Apacheを監視するルール例です。

・作業用ディレクトリに移動します。
cd /var/tmp

・viなどでコマンドが並んだファイルを作成します。スクリプトとして#!/bin/bashのような定義文は必要ありません。
　コマンドの箇条書きだけで良いです。以下例はアラートでサービス状態、アクションでサービスの再起動、
　最終アクションで監視対象サーバーのコンソールにメッセージを表示する例です。

vi /var/tmp/alert
	/etc/init.d/apache2 status

vi /var/tmp/action
	/etc/init.d/apache2 restart

vi /var/tmp/result
	echo ApacheFail | wall

・作成したファイルをアップロードします。
curl -k -X POST https://192.168.0.15:1880 -F file=@alert -F account=kato_test -F to=alert -F rulename=apache
curl -k -X POST https://192.168.0.15:1880 -F file=@action -F account=kato_test -F to=action -F rulename=apache
curl -k -X POST https://192.168.0.15:1880 -F file=@result -F account=kato_test -F to=result -F rulename=apache

５．アップロードしたリポジトリファイルをコミットし、最後にルールを定義します。

・POSTした際にルール名＋日付という形式でリポジトリファイル名が表示されますのでそれを元にコミットします。
curl -k "https://192.168.0.15:1880?cmd=commit&to=alert&account=kato_test&params=apache_2017-02-12-01-11-35"
curl -k "https://192.168.0.15:1880?cmd=commit&to=action&account=kato_test&params=apache_2017-02-12-01-11-39"
curl -k "https://192.168.0.15:1880?cmd=commit&to=result&account=kato_test&params=apache_2017-02-12-12-59-18"

・最後にルールを設定します。この例はapacheというルール名、Sなのでis.*runningが無い場合にアラート扱い、3回アクションして失敗したら
　最終アクションとなる例です。
curl -k "https://192.168.0.15:1880?account=kato_test&cmd=ruleset&params=apache_S_is.*running_3"

一度設定して問題なく動作しているのであれば同じ用途のサーバーを追加することは以下のコマンドを５個打つ、
または一行にまとめることで登録可能です。

mkdir -p /opt/sushi/out ; cd /opt/sushi
echo `curl -s -S -k "https://192.168.0.15:1880?cmd=init&password=password&params=kato3_test" | cut -d "\"" -f 12` | sed -e 's/\\n/\n/g' -e 's/\\t/\t/g' > key ; chmod 600 key
curl -k "https://192.168.0.15:1880?cmd=agentget&account=kato3_test" -o agent ; chmod 700 agent
curl -k "https://192.168.0.15:1880?account=kato_test&cmd=repocopy&to=kato3_test"
echo "* * * * * for i in `seq 0 15 59`;do (sleep ${i} ; timeout 60 /opt/sushi/agent -ip=192.168.0.15 -port=22 -user=kato3 -key=/opt/sushi/key >> /var/log/agent.log) & done;" >> /var/spool/cron/crontabs/root

または（長いですが・・）

mkdir -p /opt/sushi/out ; cd /opt/sushi ; echo `curl -s -S -k "https://192.168.0.15:1880?cmd=init&password=password&params=kato2_test" | cut -d "\"" -f 12` | sed -e 's/\\n/\n/g' -e 's/\\t/\t/g' > key ; chmod 600 key ; curl -k "https://192.168.0.15:1880?cmd=agentget&account=kato2_test" -o agent ; chmod 700 agent ; curl -k "https://192.168.0.15:1880?account=kato_test&cmd=repocopy&to=kato2_test" ; echo '* * * * * for i in `seq 0 15 59`;do (sleep ${i} ; timeout 60 /opt/sushi/agent -ip=192.168.0.15 -port=22 -user=kato2 -key=/opt/sushi/key >> /var/log/agent.log) & done;' >> /var/spool/cron/crontabs/root ; /etc/init.d/cron restart

さいごに：
実装方式が柔軟なため未実装ですが将来的に以下の拡張性を持っています。

　１．　Windows版Agentに対応
　　-　go言語で作られているため実行方法の部分をWindowsのコマンドプロンプトに置き換えることでWindowsも監視可能になる
　２．　ChatOpsに対応
　　-　フルAPIかつ、監視方法がテキストで設定できるのでBotと連携することでSlack等から監視出来るツールに
　３．　オーケストレーションに対応
　　-　監視対象Agentに任意のコマンドが投げられるので監視以外でもインベントリ収集など構成管理機能も実装可能

